<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
    //在工厂模式指生产的基础上,即要实现批量生产,也要实现品牌的区分--->js中,品牌的区分叫做"实例识别"--->构造函数模式

    //只有从构造函数模式开始,才真正的向后台一样使用面向对象思想编程

    //使用构造函数模式,可以自己创建类

    function CreateJsPerson(name,age){
        //this是浏览器默认创建的那个实例: 在构造函数模式执行的时候,方法体中的this就是当前这个类的一个实例(this的第四种情况)
        this.name=name; //给当前实例增加一个叫做name的属性名
        this.age=age;
        this.writeCss=function(){
            console.log("my name is "+name+" ,my age is "+age+" ,i can write css ");
        };
        this.writeJs=function(){
            console.log("my name is "+name+" ,my age is "+age+" ,i can write Js ");
        }
    }
    var jsPerson1=new CreateJsPerson("aaa",12);

    //一般情况下创建类,首字母大写

    //构造函数与普通函数的区别:
        //1)执行时,通过加一个new来执行,就不是普通的函数了,而是变为一个类(自定义类); 同样,返回的jsPerson1 也不再是一个变量,而是当前类的一个实例
            //普通函数:方法名();
            //构造函数:new 方法名();
        //2)运行的时候
            //-->当用new CreateJsPerson()执行后,还是会按照普通函数执行那样,先给形参赋值,然后进行私有作用域中的预解释,最后代码从上至下执行
                //(说明了,它虽然叫做类,但是也存在普通函数的那一面)
            //-->但是使用new执行,在普通函数执行的基础上多加了一些操作:
                    //在js代码执行前,浏览器会自动创建一个对象数据类型的值(这个值就是当前这个类的一个实例)
                    //在接下来的代码执行过程中,以创建的实例为执行的主体(this就是当前的实例),分别把需要增加的属性名和属性值赋值给当前的实例
                    //当代码执行完成后,浏览器会自动的把创建的实例返回到类的外面


</script>
</body>
</html>